// lib/cache/redisCache.ts
import { createClient, RedisClientType } from 'redis'

interface CacheEntry<T> {
  data: T
  timestamp: number
  expiresAt: number
  metadata?: {
    contentDate?: string
    isPermanent?: boolean
  }
}

export class RedisCache {
  private client: RedisClientType | null = null
  private isConnected: boolean = false
  private isConnecting: boolean = false
  private connectionPromise: Promise<void> | null = null

  constructor() {
    // Only initialize on server-side
    if (typeof window === 'undefined') {
      this.initializeClient()
    }
  }

  private initializeClient() {
    try {
      const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379'
      
      this.client = createClient({
        url: redisUrl,
        socket: {
          reconnectStrategy: (retries) => {
            if (retries > 10) {
              console.error('‚ùå Redis: Max reconnection attempts reached')
              return new Error('Max reconnection attempts reached')
            }
            // Exponential backoff: 100ms, 200ms, 400ms, etc.
            return Math.min(retries * 100, 3000)
          }
        }
      })

      // Error handling
      this.client.on('error', (err) => {
        console.error('‚ùå Redis Client Error:', err)
        this.isConnected = false
      })

      this.client.on('connect', () => {
        console.log('üîå Redis: Connecting...')
      })

      this.client.on('ready', () => {
        console.log('‚úÖ Redis: Connected and ready')
        this.isConnected = true
      })

      this.client.on('reconnecting', () => {
        console.log('üîÑ Redis: Reconnecting...')
        this.isConnected = false
      })

      this.client.on('end', () => {
        console.log('üîå Redis: Connection closed')
        this.isConnected = false
      })

    } catch (error) {
      console.error('‚ùå Redis: Failed to create client:', error)
      this.client = null
    }
  }

  private async ensureConnection(): Promise<boolean> {
    if (!this.client) {
      return false
    }

    if (this.isConnected) {
      return true
    }

    // If already connecting, wait for that connection
    if (this.isConnecting && this.connectionPromise) {
      try {
        await this.connectionPromise
        return this.isConnected
      } catch {
        return false
      }
    }

    // Start new connection
    this.isConnecting = true
    this.connectionPromise = this.client.connect()
      .then(() => {
        this.isConnected = true
        this.isConnecting = false
      })
      .catch((error) => {
        console.error('‚ùå Redis: Connection failed:', error)
        this.isConnected = false
        this.isConnecting = false
        throw error
      })

    try {
      await this.connectionPromise
      return this.isConnected
    } catch {
      return false
    }
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const connected = await this.ensureConnection()
      if (!connected || !this.client) {
        return null
      }

      const value = await this.client.get(key)
      if (!value) {
        return null
      }

      const cacheEntry: CacheEntry<T> = JSON.parse(value)
      const now = Date.now()

      // Check if permanent cache
      if (cacheEntry.metadata?.isPermanent) {
        console.log(`‚úÖ Redis cache HIT (PERMANENT): ${key}`)
        return cacheEntry.data
      }

      // Check if expired
      if (now > cacheEntry.expiresAt) {
        await this.delete(key)
        console.log(`‚è∞ Redis cache expired: ${key}`)
        return null
      }

      const remainingTime = Math.round((cacheEntry.expiresAt - now) / 1000 / 60)
      console.log(`‚úÖ Redis cache HIT: ${key} (${remainingTime} min remaining)`)
      return cacheEntry.data

    } catch (error) {
      console.error('‚ùå Redis get error:', error)
      return null
    }
  }

  async set<T>(
    key: string,
    data: T,
    ttl: number,
    metadata?: { contentDate?: string }
  ): Promise<void> {
    try {
      const connected = await this.ensureConnection()
      if (!connected || !this.client) {
        console.warn('‚ö†Ô∏è Redis not connected, skipping cache set')
        return
      }

      const now = Date.now()
      const ONE_YEAR = 365 * 24 * 60 * 60 * 1000
      const isPermanent = ttl >= ONE_YEAR

      const cacheEntry: CacheEntry<T> = {
        data,
        timestamp: now,
        expiresAt: now + ttl,
        metadata: {
          ...metadata,
          isPermanent
        }
      }

      const value = JSON.stringify(cacheEntry)
      
      // Set with TTL in seconds
      const ttlSeconds = Math.ceil(ttl / 1000)
      await this.client.setEx(key, ttlSeconds, value)

      const ttlMinutes = Math.round(ttl / 1000 / 60)
      const ttlDisplay = isPermanent ? 'PERMANENT' : `${ttlMinutes} min`
      console.log(`üíæ Redis cache SET: ${key} (${ttlDisplay})`)

    } catch (error) {
      console.error('‚ùå Redis set error:', error)
    }
  }

  async delete(key: string): Promise<void> {
    try {
      const connected = await this.ensureConnection()
      if (!connected || !this.client) {
        return
      }

      await this.client.del(key)
      console.log(`üóëÔ∏è Redis cache DELETE: ${key}`)
    } catch (error) {
      console.error('‚ùå Redis delete error:', error)
    }
  }

  async clear(pattern?: string): Promise<void> {
    try {
      const connected = await this.ensureConnection()
      if (!connected || !this.client) {
        return
      }

      if (pattern) {
        // Use SCAN to find matching keys
        const keys: string[] = []
        let cursor = 0

        do {
          const result = await this.client.scan(cursor, {
            MATCH: `*${pattern}*`,
            COUNT: 100
          })
          cursor = result.cursor
          keys.push(...result.keys)
        } while (cursor !== 0)

        if (keys.length > 0) {
          await this.client.del(keys)
          console.log(`üóëÔ∏è Redis: Cleared ${keys.length} keys matching: ${pattern}`)
        }
      } else {
        // Clear all keys
        await this.client.flushDb()
        console.log('üóëÔ∏è Redis: Cleared all cache')
      }
    } catch (error) {
      console.error('‚ùå Redis clear error:', error)
    }
  }

  async cleanExpired(): Promise<void> {
    // Redis automatically handles TTL expiration
    // This method is for consistency with other cache layers
    console.log('‚ÑπÔ∏è Redis handles TTL expiration automatically')
  }

  async getStats(): Promise<{
    count: number
    memory: number
    connected: boolean
  }> {
    try {
      const connected = await this.ensureConnection()
      if (!connected || !this.client) {
        return { count: 0, memory: 0, connected: false }
      }

      const info = await this.client.info('stats')
      const keyspace = await this.client.info('keyspace')
      
      // Parse keyspace info to get key count
      const dbMatch = keyspace.match(/db0:keys=(\d+)/)
      const keyCount = dbMatch ? parseInt(dbMatch[1]) : 0

      // Parse memory info
      const memoryMatch = info.match(/used_memory:(\d+)/)
      const memoryBytes = memoryMatch ? parseInt(memoryMatch[1]) : 0

      return {
        count: keyCount,
        memory: memoryBytes,
        connected: this.isConnected
      }
    } catch (error) {
      console.error('‚ùå Redis stats error:', error)
      return { count: 0, memory: 0, connected: false }
    }
  }

  async ping(): Promise<boolean> {
    try {
      const connected = await this.ensureConnection()
      if (!connected || !this.client) {
        return false
      }

      const result = await this.client.ping()
      return result === 'PONG'
    } catch {
      return false
    }
  }

  async disconnect(): Promise<void> {
    try {
      if (this.client && this.isConnected) {
        await this.client.quit()
        console.log('üëã Redis: Disconnected')
      }
    } catch (error) {
      console.error('‚ùå Redis disconnect error:', error)
    }
  }
}

// Singleton instance
export const redisCache = new RedisCache()